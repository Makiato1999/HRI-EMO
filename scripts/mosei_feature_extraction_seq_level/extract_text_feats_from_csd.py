#!/usr/bin/env python3
import argparse
from pathlib import Path
import json

import torch
import pandas as pd
from mmsdk import mmdatasdk
import numpy as np

def parse_args():
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--data_root",
        type=str,
        default="data/MOSEI",
        help="Folder where MOSEI .csd files are stored (e.g., data/MOSEI)",
    )
    ap.add_argument(
        "--index_csv",
        type=str,
        default="data/mosei_index_splits.csv",
        help="Index CSV generated by build_mosei_index_splits.py",
    )
    ap.add_argument(
        "--out_dir",
        type=str,
        default="features/mosei/seq_level/text",
        help="Where to save [uid].pt features",
    )
    ap.add_argument(
        "--max_samples",
        type=int,
        default=None,
        help="Optional: limit number of segments to process.",
    )
    return ap.parse_args()


def main():
    args = parse_args()

    data_root = Path(args.data_root)
    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    df = pd.read_csv(args.index_csv)

    if args.max_samples is not None and args.max_samples < len(df):
        df = df.sample(args.max_samples, random_state=42).reset_index(drop=True)
        print(f"[Info] Using subset of {len(df)} segments (max_samples={args.max_samples})")

    mosei = mmdatasdk.cmu_mosei

    # 文本特征 view 名固定
    text_key = "CMU_MOSEI_TimestampedWordVectors"

    # label: mosei.labels 的 value 在你环境里是 URL，我们只要文件名
    label_key, label_val = next(iter(mosei.labels.items()))
    label_csd_name = Path(str(label_val)).name  # 去掉前面的 http://...
    # 一般就是 "CMU_MOSEI_Labels.csd"

    text_csd = data_root / f"{text_key}.csd"
    label_csd = data_root / label_csd_name

    missing = []
    if not text_csd.exists():
        missing.append(str(text_csd))
    if not label_csd.exists():
        missing.append(str(label_csd))
    if missing:
        raise FileNotFoundError(
            "Missing required .csd files:\n  "
            + "\n  ".join(missing)
            + "\n请确认它们都在 --data_root 指定的目录下。"
        )

    # 显式指定：key -> 本地文件路径
    recipe = {
        text_key: str(text_csd),
        label_key: str(label_csd),
    }

    print(f"[Info] Loading dataset from local CSDs in {data_root} (text + labels only)")
    ds = mmdatasdk.mmdataset(recipe)

    # 对齐到 labels，得到 segment 级 key：video_id[seg_idx]
    ds.align(label_key)

    if text_key not in ds.computational_sequences:
        raise KeyError(
            f"{text_key} not found after loading. "
            f"Available keys: {list(ds.computational_sequences.keys())}"
        )

    text_data = ds.computational_sequences[text_key].data
    label_data = ds.computational_sequences[label_key].data

    print(
        f"[Info] After alignment: {len(text_data)} entries in text view, "
        f"{len(label_data)} entries in label view"
    )

    # 检查 index_csv 是否和对齐后的 key 风格匹配
    if len(df) > 0:
        test_vid = df.iloc[0]["video_id"]
        test_seg = int(df.iloc[0]["seg_idx"])
        test_key = f"{test_vid}[{test_seg}]"
        if test_key not in text_data:
            example_keys = list(text_data.keys())[:10]
            raise RuntimeError(
                "Cannot match CSV with aligned dataset keys.\n"
                f"Example CSV video_id: {test_vid}\n"
                f"Example CSV uid: {df.iloc[0]['uid']}\n"
                f"Expected aligned key (from CSV): {test_key}\n"
                f"Example aligned keys: {example_keys}\n"
                "请确认：build_mosei_index_splits.py 用的是同一套本地 CSD，未被手改。"
            )

    saved = 0
    dim = None

    for _, row in df.iterrows():
        vid = row["video_id"]
        seg_idx = int(row["seg_idx"])
        uid = row["uid"]

        seg_key = f"{vid}[{seg_idx}]"

        if seg_key not in text_data or seg_key not in label_data:
            continue

        feats = text_data[seg_key]["features"]  # [L, D] 或 [D]

        if hasattr(feats, "ndim") and feats.ndim == 1:
            feats = feats[None, :]

        feats = np.nan_to_num(feats, nan=0.0, posinf=0.0, neginf=0.0)

        h = torch.from_numpy(feats).float()
        if h.ndim != 2:
            continue

        L, D = h.shape
        attn = torch.ones(L, dtype=torch.long)

        if dim is None:
            dim = D

        torch.save(
            {
                "hidden": h,
                "attention_mask": attn,
            },
            out_dir / f"{uid}.pt",
        )
        saved += 1

    meta = {
        "source": text_key,
        "hidden_dim": dim,
        "num_segments": saved,
        "note": (
            "MOSEI text seq-level features from CMU_MOSEI_TimestampedWordVectors, "
            "aligned to labels at segment level. Uses only local CSDs."
        ),
    }
    (out_dir / "meta.json").write_text(json.dumps(meta, indent=2), encoding="utf-8")

    print(f"[OK] Saved {saved} text seq-level features to {out_dir}")


if __name__ == "__main__":
    main()
